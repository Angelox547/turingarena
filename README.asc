= TuringArena - Create algorithmic challanges

TuringArena lets you define a problem which requires an algorithmic solution,
and then automatically test the code of any provided solution.

== Getting started

We recommend using a python virtualenv to use this software from source
(see http://virtualenvwrapper.readthedocs.io/[the virtualenvwrapper documentation]).

Commands to setup and use a virtualenv (on Debian, using virtualenvwrapper):

[source,bash]
  $ sudo apt-get install python3-virtualenv virtualenvwrapper # install virtualenvwrapper
  $ mkvirtualenv -p /usr/bin/python3 turingarena # create a virualenv named 'turingarena'
  $ workon turingarena # use your shiny virtualenv
  $ deactivate # exit the virtualenv

Once you set-up your virtualenv,
clone or download the repository (follow GitHub instruction)
then `cd` into the cloned/download folder and run:

[source,bash]
  $ workon turingarena
  $ python setup.py develop

== Goals

* Writing a solution should require little-to-no usage of low-level primitives,
  not even reading/writing from a file/stdin/stdout.
  
* Defining a problem should require a knowledge as similar as possible to that
  required for writing solutions.
  
* A problem can accept more than one solution at a time,
  written by different people,
  that can be evaluated together or against each other.
  
* Many programming languages should be supported,
  both for defining problems and for writing solutions,
  allowing different languages to interoperate during the evaluation.
  (Say, a problem written in python can be used to test a solution written in C,
  two solutions written in C and Java can be evaluated against each other, etc.)

== How to define a problem

At the very least, a problem must define:

* the interface that solution algorithms are required to implement 
* the logic used to evaluate solutions.

The first point is done by writing a file `interfaces.txt`,
in a simple C-like syntax, which defines the interface.

The second point is done by writing a program,
in the programming language of choice,
which tests and evaluates a solution.
For writing this program, a library of tools is provided
which allows to:

* run the code of a solution in a new (sandboxed) process
* limit the time and memory usage of solutions
* invoke functions defined in a solution and receive back data
* let the solutions invoke callbacks defined in the module

These tools are in part provided by TuringArena,
in part generated automatically from the `interfaces.txt` file.

== Problem definition concepts

Problem Definition::
  The set of files created by the problem writed to define a problem.

Interface::
  Interfaces specify which functions an algorithm should implement,
  which functions (callbacks) it can use, and the type of data
  it can exchange.

Algorithm::
  An algorithm is an implementation of an interface.
  An algorithm is usually defined as the solution of a problem,
  but can be also defined by the problem writer herself.
  To define an algorithm, a single file of source code is required.
  In general, there may be more than one algorithm
  that implements the same interface.

Process::
  A process is the execution of an algorithm.
  More than one process can be started,
  even for the same algorithm.
  Each process runs in a separate sandbox:
  that is, it has its own memory, which is not shared
  with other processes.

== TuringArena internal concepts

Interface Support::
  Libraries and code generated by TuringArena to compile and run
  any algorithm implementing a given interface.
  The support is automatically generated for every interface
  and for every supported programming language.
  The support for an interface is reused by all the algorithms
  implementing that interface (say, different solutions).
