= TaskWizard - Create algorithmic challanges

TaskWizard lets you define a problem which requires an algorithmic solution,
and then automatically test the code of any provided solution.

== Getting started

Clone or download the repository (follow GitHub instruction)
and `cd` into the cloned/download folder.

To build/install, run

    sh build/scripts.sh

and follow instructions.

== Goals

* Writing a solution should require little-to-no usage of low-level primitives,
  not even reading/writing from a file/stdin/stdout.
  
* Defining a problem should require a knowledge as similar as possible to that
  required for writing solutions.
  
* A problem can accept more than one solution at a time,
  written by different people,
  that can be evaluated together or against each other.
  
* Many programming languages should be supported,
  both for defining problems and for writing solutions,
  allowing different languages to interoperate during the evaluation.
  (Say, a problem written in python can be used to test a solution written in C,
  two solutions written in C and Java can be evaluated against each other, etc.)

== How to define a problem

At the very least, a problem must define:

* the interface that solution algorithms are required to implement 
* the logic used to evaluate solutions.

The first point is done by writing a file `task.txt`,
in a simple C-like syntax, which defines the interface.

The second point is done by writing a program (called _module_),
in the programming language of choice,
which tests a solution.
For writing the module, a library of tools is provided
which allows to:

* run the code of a solution in a new (sandboxed) process
* limit the time and memory usage of solutions
* invoke functions defined in a solution and receive back data
* let the solutions invoke callbacks defined in the module

These tools are in part provided by TaskWizard,
in part generated automatically from the `task.txt` file.

== Problem definition concepts

Problem Definition::
  The set of files created by the problem writed to define a problem.

Problem Definition Folder::
  The folder where the problem writer defines a problem.
  The folder can be structured as desired by the problem writer,
  but the following conventions are recommended:
  TBD.

Interface::
  Interfaces specify which functions an algorithm should implement,
  which functions (callbacks) it can use, and the type of data
  it can exchange.

Algorithm::
  An algorithm is an implementation of an interface.
  An algorithm is usually defined as the solution of a problem,
  but can be also defined by the problem writer herself.
  To define an algorithm, a single file of source code is required.
  In general, there may be more than one algorithm
  that implements the same interface.

Module::
  A program defined by the problem writer.
  It can test one or more algorithms,
  process input data or generate output data.
  A module is usually defined with a single file of source code.
  
Module Entry Point::
  In a module, specifies
  a function to be called,
  a collection of parameters (input) and
  a collection of data that should be generated (output).

  Each parameter can be:

  * an algorithm (of a given interface) that the module can use,
  * data that the module can read.

Process::
  A process is the execution of an algorithm, started by a module.
  More than one process can be started by a module,
  even for the same algorithm.
  Each process runs in a separate sandbox:
  that is, it has its own memory, which is not shared
  with other processes.

== TaskWizard internal concepts

Interface Support::
  Libraries and code generated by TaskWizard to compile and run
  any algorithm implementing a given interface.
  The support is automatically generated for every interface
  and for every programming language.
  The support for an interface is reused by all the algorithms
  implementing that interface (say, different solutions).
  
Module Support::
  Libraries and code generated by TaskWizard to compile and run a module.
  The module support is automatically generated for each module
  (only for the specific programming language used to define that module)
  and is combined with the module source code.

Supervisor::
  A program, part of TaskWizard, which manages the execution
  of a module.
  The supervisor runs the module in a sandbox,
  and communicates with it via named pipes.
  It receives instructions from the module to start/stop processes,
  and to open files for reading and writing.
  It manages the communication between module and processes.

Problem Building::
  The generation of all the files used for evaluation.
  Comprises the following phases:
  
  . Preparation
  . Compilation
  . Verification

Problem Preparation::
  Phase of problem building which is deterministic and machine-independent.
  Comprises, e.g., source-code generation.
  The result of this phase is the problem generated folder,
  which could be in principle packaged and/or transferred to any other machine
  before the next building phase.

Problem Compilation::
  Phase of problem building which is possibly non-deterministic and/or machine-dependent.
  Comprises, e.g., compilation of module source code into object code.
  The result of this phase is the problem compiled folder.

Problem Verification::
  Phase of problem building which consists of a collection of evaluations
  with provided submissions, each possibly with an expected result to be verified.

Problem Prepared/Compiled Folder::
  Folders containing all the stuff generated by the problem preparation/compilation.
  They are structured as follows:
  
  * `interfaces/<name>/<lang>/`: interface support for interface `<name>` and language `<lang>`
  * `algorithms/<name>/`: source sode of algorithm `<name>` (provided by the problem writer)
  * `modules/<name>/`: module support and source code of module `<name>`

Run Folder::
  The folder containing stuff related to the execution
  of a _single entry point_ of a module.
  The supervisor starts in this folder.
  It contains the following:
  
  * `module/`: module associated with the current run, in a ready to execute (compiled) form
  * `algorithms/<name>/`: algorithm `<name>`, in a ready to execute (compiled) form
  (the algorithm `<name>` is either taken from the problem definition or from a submission,
  as specified by the current entry point)
  * `inputs/<name>/data.txt`: readable file `<name>` specified by the current entry point
  * `outputs/<name>/data.txt`: writable file `<name>` specified by the current entry point

Problem Bare Folder::
  A folder that contains other sub-folders related to a problem
  in an organized fashion.
  Command line programs only works with bare folder,
  mantaining the same structure.
  This way, the same folder can be specified
  for different commands, without conflicts,
  and command line arguments are simplified.
  Any element of the bare folder can be missing.
  The problem definition folder (i.e., the problem writer workspace)
  contains a problem base folder under `.task/`.
  The bare folder has the following structure:
  
  * `build/definition/`: the problem definition folder
  (only for packaging/distribution, since normally the definition folder is the parent of the bare folder)
  * `build/prepared/`: the problem prepared folder
  * `build/compiled/`: the problem compiled folder
  * `runs/<id>/`: run folders
  * `latest_run.txt`: contains the id of the latest run (useful for CLI commands)

== Module execution details

Descriptor::
  A numeric ID assigned by the supervisor to processes, and input/output files.

Module Sandbox::
  Folder where a module is run.
  It is created and managed by the supervisor.
  It contains the following files
  (`<fd>` is replaced by the specific process/file descriptor,
  as returned by the supervisor in the response):
  
  * `control_request.pipe`
  * `control_response.pipe`
  * `process_downward.<fd>.pipe`
  * `process_upward.<fd>.pipe`

Control Request Pipe::
  A pipe where a module writes command for the supervisor
  (read from the supervisor).

Control Response Pipe::
  A pipe where the supervisor writes responses to module requests
  (read from the module).

Process Downward Pipe::
  A pipe where the module writes and a process reads.

Process Upward Pipe::
  A pipe where a process writes and the module reads.

